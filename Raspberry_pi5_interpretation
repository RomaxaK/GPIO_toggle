import tkinter as tk
from tkinter import filedialog
import serial
import threading
import subprocess
import re
import csv
import pandas as pd
from datetime import datetime
from collections import deque
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.animation import FuncAnimation

# ====== Data Buffers ======
throughputs = deque(maxlen=200)
time_points = deque(maxlen=200)
time_counter = 0
lock = threading.Lock()

class SerialReader(threading.Thread):
    def __init__(self, port, baudrate, callback):
        super().__init__(daemon=True)
        self.callback = callback
        self.ser = serial.Serial(port, baudrate, timeout=1)

    def run(self):
        while True:
            try:
                line = self.ser.readline().decode(errors='ignore').strip()
                if line.startswith("STATS"):
                    parts = line.split(',')
                    if len(parts) == 3:
                        try:
                            _, req, grant = parts
                            self.callback(int(req.strip()), int(grant.strip()))
                        except:
                            pass
            except Exception as e:
                print(f"Serial error: {e}")

    def send_command(self, cmd: str):
        try:
            print(f"[UART SEND] {cmd}")
            self.ser.write((cmd + '\n').encode())
        except Exception as e:
            print(f"Write error: {e}")

class ThroughputPlot:
    def __init__(self, parent, config_getter):
        self.fig, self.ax = plt.subplots(figsize=(5, 3))
        self.canvas = FigureCanvasTkAgg(self.fig, master=parent)
        self.toolbar = NavigationToolbar2Tk(self.canvas, parent)
        self.toolbar.update()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        self.ani = FuncAnimation(self.fig, self.update_plot, interval=1000, blit=False)
        self.iperf_process = None
        self.running = False
        self.log_file = None
        self.log_writer = None
        self.full_log_file = None
        self.full_log_writer = None
        self.config_getter = config_getter

        # Connect pan/zoom event
        self.ax.callbacks.connect('xlim_changed', self.on_xlim_change)
        self.showing_historical = False

    def update_plot(self, frame):
        if self.showing_historical:
            return  # Skip live update if showing historical data
        with lock:
            if not time_points or not throughputs:
                return
            self.ax.clear()
            self.ax.plot(time_points, throughputs, label="Throughput (Mbit/s)")
            self.ax.set_title("iPerf3 Throughput (Live)")
            self.ax.set_xlabel("Time (s)")
            self.ax.set_ylabel("Mbit/s")
            self.ax.grid(True)
            self.ax.legend()

    def on_xlim_change(self, event_ax):
        xlim = event_ax.get_xlim()
        left, right = int(xlim[0]), int(xlim[1])

        if left < max(0, time_counter - 200):
            print(f"[PANNING BACK] Loading historical data: {left} to {right}")
            self.load_historical_data(left, right)
            self.showing_historical = True
        elif self.showing_historical and left >= max(0, time_counter - 200):
            print(f"[RETURNING TO LIVE VIEW]")
            self.showing_historical = False

    def load_historical_data(self, start_time, end_time):
        df = pd.read_csv(self.full_log_file.name)
        slice_df = df[(df["Time (s)"] >= start_time) & (df["Time (s)"] <= end_time)]

        self.ax.clear()
        self.ax.plot(slice_df["Time (s)"], slice_df["Throughput (Mbit/s)"], label="Throughput (Mbit/s)")
        self.ax.set_title(f"iPerf3 Historical {start_time}-{end_time}s")
        self.ax.set_xlabel("Time (s)")
        self.ax.set_ylabel("Mbit/s")
        self.ax.grid(True)
        self.ax.legend()
        self.canvas.draw()

    def start_iperf(self):
        if self.running:
            print("[iPerf3] Already running.")
            return
        self.running = True

        ip, port, duration, interval, iperf_path = self.config_getter()

        log_name = f"iperf3_log_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv"
        full_log_name = f"iperf3_full_log_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv"

        self.log_file = open(log_name, 'w', newline='')
        self.log_writer = csv.writer(self.log_file)
        self.log_writer.writerow(["Time (s)", "Throughput (Mbit/s)"])

        self.full_log_file = open(full_log_name, 'w', newline='')
        self.full_log_writer = csv.writer(self.full_log_file)
        self.full_log_writer.writerow(["Time (s)", "Throughput (Mbit/s)"])

        def run():
            global time_counter
            cmd = [iperf_path, "-c", ip, "-p", port, "-i", interval, "-t", duration, "--forceflush"]
            try:
                print(f"[iperf3 started] {cmd}")
                self.iperf_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                for line in iter(self.iperf_process.stdout.readline, ''):
                    if not self.running:
                        break
                    line = line.strip()
                    print(f"[iperf3 stdout] {line}")
                    match = re.search(r'\[\s*\d+\]\s+\d+\.\d+-\d+\.\d+\s+sec\s+\S+\s+\S+\s+(\d+\.\d+|\d+)\s+Mbits/sec', line)
                    if match:
                        throughput = float(match.group(1))
                        print(f"[throughput matched] {throughput}")
                        with lock:
                            throughputs.append(throughput)
                            time_points.append(time_counter)
                            time_counter += 1
                        self.log_writer.writerow([time_counter, throughput])
                        self.full_log_writer.writerow([time_counter, throughput])
            except Exception as e:
                print(f"[iperf3 error] {e}")
            finally:
                self.running = False
                if self.iperf_process:
                    self.iperf_process = None
                if self.log_file:
                    self.log_file.close()
                    self.log_file = None
                    self.log_writer = None
                if self.full_log_file:
                    self.full_log_file.close()
                print("[iperf3] Process stopped.")

        threading.Thread(target=run, daemon=True).start()

    def stop_iperf(self):
        if self.iperf_process and self.running:
            print("[iperf3] Terminating...")
            self.iperf_process.terminate()
            self.running = False

    def save_log_now(self):
        log_name = f"manual_export_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv"
        with open(log_name, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["Time (s)", "Throughput (Mbit/s)"])
            with lock:
                for t, th in zip(time_points, throughputs):
                    writer.writerow([t, th])
        print(f"[Log saved manually] {log_name}")

class ESP32IperfGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ESP32 + iPerf3 Monitor")
        self.reader = None
        self.last_req = -1
        self.last_grant = -1
        self.build_gui()

    def build_gui(self):
        left = tk.Frame(self.root)
        left.pack(side=tk.LEFT, padx=10, pady=10)

        tk.Label(left, text="Serial Port:").pack()
        self.serial_port_entry = tk.Entry(left)
        self.serial_port_entry.insert(0, "COM9")
        self.serial_port_entry.pack()

        tk.Label(left, text="Baud Rate:").pack()
        self.baudrate_entry = tk.Entry(left)
        self.baudrate_entry.insert(0, "115200")
        self.baudrate_entry.pack()

        tk.Label(left, text="iPerf3 Path:").pack()
        self.iperf_path_entry = tk.Entry(left, width=40)
        self.iperf_path_entry.insert(0, "C:/Users/rk52524/Downloads/iperf3.12_64/iperf3.exe")
        self.iperf_path_entry.pack()
        tk.Button(left, text="Browse", command=self.browse_iperf_path).pack(pady=3)

        tk.Button(left, text="Always Grant", command=lambda: self.reader.send_command("CMD,GRANT_MODE,ALWAYS")).pack(pady=3)
        tk.Button(left, text="No Grant", command=lambda: self.reader.send_command("CMD,GRANT_MODE,NONE")).pack(pady=3)
        tk.Button(left, text="Random Grant", command=lambda: self.reader.send_command("CMD,GRANT_MODE,RANDOM")).pack(pady=3)
        tk.Button(left, text="Clear Counters", command=self.clear_counters).pack(pady=5)

        tk.Label(left, text="Server IP:").pack()
        self.ip_entry = tk.Entry(left)
        self.ip_entry.insert(0, "192.168.1.4")
        self.ip_entry.pack()

        tk.Label(left, text="Port:").pack()
        self.port_entry = tk.Entry(left)
        self.port_entry.insert(0, "5202")
        self.port_entry.pack()

        tk.Label(left, text="Duration (s):").pack()
        self.duration_entry = tk.Entry(left)
        self.duration_entry.insert(0, "9999")
        self.duration_entry.pack()

        tk.Label(left, text="Interval (s):").pack()
        self.interval_entry = tk.Entry(left)
        self.interval_entry.insert(0, "1")
        self.interval_entry.pack()

        tk.Button(left, text="Start iPerf3", command=self.start_iperf).pack(pady=3)
        tk.Button(left, text="Stop iPerf3", command=self.stop_iperf).pack(pady=3)
        tk.Button(left, text="Save Log", command=self.save_log).pack(pady=3)

        self.req_label = tk.Label(left, text="Requests: 0", font=("Arial", 12))
        self.req_label.pack(pady=10)
        self.grant_label = tk.Label(left, text="Grants: 0", font=("Arial", 12))
        self.grant_label.pack(pady=10)

        right = tk.Frame(self.root)
        right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.plot = ThroughputPlot(right, self.get_config)

    def browse_iperf_path(self):
        path = filedialog.askopenfilename(title="Select iperf3 executable", filetypes=[("Executable", "*.exe")])
        if path:
            self.iperf_path_entry.delete(0, tk.END)
            self.iperf_path_entry.insert(0, path)

    def get_config(self):
        return (
            self.ip_entry.get().strip(),
            self.port_entry.get().strip(),
            self.duration_entry.get().strip(),
            self.interval_entry.get().strip(),
            self.iperf_path_entry.get().strip()
        )

    def start_iperf(self):
        if self.reader is None:
            port = self.serial_port_entry.get().strip()
            baudrate = int(self.baudrate_entry.get().strip())
            self.reader = SerialReader(port, baudrate, self.update_stats)
            self.reader.start()

        with lock:
            throughputs.clear()
            time_points.clear()
            global time_counter
            time_counter = 0
        self.plot.start_iperf()

    def stop_iperf(self):
        self.plot.stop_iperf()

    def save_log(self):
        self.plot.save_log_now()

    def clear_counters(self):
        if self.reader:
            self.reader.send_command("CMD,RESET_COUNTERS")
        self.last_req = 0
        self.last_grant = 0
        self.req_label.config(text="Requests: 0")
        self.grant_label.config(text="Grants: 0")
        print("[Counters cleared on ESP32 and GUI]")

    def update_stats(self, req, grant):
        if req != self.last_req:
            self.req_label.config(text=f"Requests: {req}")
            self.last_req = req
        if grant != self.last_grant:
            self.grant_label.config(text=f"Grants: {grant}")
            self.last_grant = grant

if __name__ == "__main__":
    root = tk.Tk()
    app = ESP32IperfGUI(root)
    root.mainloop()
