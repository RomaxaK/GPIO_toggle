import tkinter as tk
from tkinter import filedialog
import serial
import threading
import subprocess
import re
import csv
from datetime import datetime
from collections import deque
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.animation import FuncAnimation

# ====== Serial Configuration ======
SERIAL_PORT = 'COM9'
BAUD_RATE = 115200

# ====== Data Buffers ======
throughputs = deque(maxlen=100)
time_points = deque(maxlen=100)
time_counter = 0
lock = threading.Lock()

# ====== Serial Communication Thread ======
class SerialReader(threading.Thread):
    def __init__(self, callback):
        super().__init__(daemon=True)
        self.callback = callback
        self.ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)

    def run(self):
        while True:
            try:
                line = self.ser.readline().decode(errors='ignore').strip()
                if line.startswith("STATS"):
                    parts = line.split(',')
                    if len(parts) == 3:
                        try:
                            _, req, grant = parts
                            self.callback(int(req.strip()), int(grant.strip()))
                        except:
                            pass
            except Exception as e:
                print(f"Serial error: {e}")

    def send_command(self, cmd: str):
        try:
            print(f"[UART SEND] {cmd}")
            self.ser.write((cmd + '\n').encode())
        except Exception as e:
            print(f"Write error: {e}")

# ====== Throughput Plot Component ======
class ThroughputPlot:
    def __init__(self, parent, config_getter):
        self.fig, self.ax = plt.subplots(figsize=(5, 3))
        self.canvas = FigureCanvasTkAgg(self.fig, master=parent)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        self.ani = FuncAnimation(self.fig, self.update_plot, interval=1000, blit=False)
        self.iperf_process = None
        self.running = False
        self.log_file = None
        self.log_writer = None
        self.config_getter = config_getter

    def update_plot(self, frame):
        with lock:
            if not time_points or not throughputs:
                return
            self.ax.clear()
            self.ax.plot(time_points, throughputs, label="Throughput (Mbit/s)")
            self.ax.set_title("iPerf3 Throughput")
            self.ax.set_xlabel("Time (s)")
            self.ax.set_ylabel("Mbit/s")
            self.ax.grid(True)
            self.ax.legend()

    def start_iperf(self):
        if self.running:
            print("[iPerf3] Already running.")
            return
        self.running = True

        ip, port, duration, interval, iperf_path = self.config_getter()

        log_name = f"iperf3_log_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv"
        self.log_file = open(log_name, 'w', newline='')
        self.log_writer = csv.writer(self.log_file)
        self.log_writer.writerow(["Time (s)", "Throughput (Mbit/s)"])

        def run():
            global time_counter
            cmd = [iperf_path, "-c", ip, "-p", port, "-i", interval, "-t", duration, "--forceflush"]
            try:
                print(f"[iperf3 started] {cmd}")
                self.iperf_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                for line in iter(self.iperf_process.stdout.readline, ''):
                    if not self.running:
                        break
                    line = line.strip()
                    print(f"[iperf3 stdout] {line}")
                    match = re.search(r'\[\s*\d+\]\s+\d+\.\d+-\d+\.\d+\s+sec\s+\S+\s+\S+\s+(\d+\.\d+|\d+)\s+Mbits/sec', line)
                    if match:
                        throughput = float(match.group(1))
                        print(f"[throughput matched] {throughput}")
                        with lock:
                            throughputs.append(throughput)
                            time_points.append(time_counter)
                            time_counter += 1
                        self.log_writer.writerow([time_counter, throughput])
            except Exception as e:
                print(f"[iperf3 error] {e}")
            finally:
                self.running = False
                if self.iperf_process:
                    self.iperf_process = None
                if self.log_file:
                    self.log_file.close()
                    self.log_file = None
                    self.log_writer = None
                print("[iperf3] Process stopped.")

        threading.Thread(target=run, daemon=True).start()

    def stop_iperf(self):
        if self.iperf_process and self.running:
            print("[iperf3] Terminating...")
            self.iperf_process.terminate()
            self.running = False

    def save_log_now(self):
        log_name = f"manual_export_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv"
        with open(log_name, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["Time (s)", "Throughput (Mbit/s)"])
            with lock:
                for t, th in zip(time_points, throughputs):
                    writer.writerow([t, th])
        print(f"[Log saved manually] {log_name}")

# ====== GUI Application ======
class ESP32IperfGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ESP32 + iPerf3 Monitor")
        self.reader = SerialReader(self.update_stats)
        self.reader.start()
        self.last_req = -1
        self.last_grant = -1
        self.build_gui()

    def build_gui(self):
        left = tk.Frame(self.root)
        left.pack(side=tk.LEFT, padx=10, pady=10)

        # iPerf3 Path
        tk.Label(left, text="iPerf3 Path:").pack()
        self.iperf_path_entry = tk.Entry(left, width=40)
        self.iperf_path_entry.insert(0, "C:/Users/rk52524/Downloads/iperf3.12_64/iperf3.exe")
        self.iperf_path_entry.pack()
        tk.Button(left, text="Browse", command=self.browse_iperf_path).pack(pady=3)

        # Grant Mode Buttons
        tk.Button(left, text="Always Grant", command=lambda: self.reader.send_command("CMD,GRANT_MODE,ALWAYS")).pack(pady=3)
        tk.Button(left, text="No Grant", command=lambda: self.reader.send_command("CMD,GRANT_MODE,NONE")).pack(pady=3)
        tk.Button(left, text="Random Grant", command=lambda: self.reader.send_command("CMD,GRANT_MODE,RANDOM")).pack(pady=3)

        # iPerf3 Config
        tk.Label(left, text="Server IP:").pack()
        self.ip_entry = tk.Entry(left)
        self.ip_entry.insert(0, "192.168.1.4")
        self.ip_entry.pack()

        tk.Label(left, text="Port:").pack()
        self.port_entry = tk.Entry(left)
        self.port_entry.insert(0, "5202")
        self.port_entry.pack()

        tk.Label(left, text="Duration (s):").pack()
        self.duration_entry = tk.Entry(left)
        self.duration_entry.insert(0, "9999")
        self.duration_entry.pack()

        tk.Label(left, text="Interval (s):").pack()
        self.interval_entry = tk.Entry(left)
        self.interval_entry.insert(0, "1")
        self.interval_entry.pack()

        # iPerf3 Controls
        tk.Button(left, text="Start iPerf3", command=self.start_iperf).pack(pady=3)
        tk.Button(left, text="Stop iPerf3", command=self.stop_iperf).pack(pady=3)
        tk.Button(left, text="Save Log", command=self.save_log).pack(pady=3)

        # Counters
        self.req_label = tk.Label(left, text="Requests: 0", font=("Arial", 12))
        self.req_label.pack(pady=10)
        self.grant_label = tk.Label(left, text="Grants: 0", font=("Arial", 12))
        self.grant_label.pack(pady=10)
        tk.Button(left, text="Clear Counters", command=self.clear_counters).pack(pady=5)

        right = tk.Frame(self.root)
        right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.plot = ThroughputPlot(right, self.get_config)

    def browse_iperf_path(self):
        path = filedialog.askopenfilename(title="Select iperf3 executable", filetypes=[("Executable", "*.exe")])
        if path:
            self.iperf_path_entry.delete(0, tk.END)
            self.iperf_path_entry.insert(0, path)

    def get_config(self):
        return (
            self.ip_entry.get().strip(),
            self.port_entry.get().strip(),
            self.duration_entry.get().strip(),
            self.interval_entry.get().strip(),
            self.iperf_path_entry.get().strip()
        )

    def start_iperf(self):
        with lock:
            throughputs.clear()
            time_points.clear()
            global time_counter
            time_counter = 0
        self.plot.start_iperf()

    def stop_iperf(self):
        self.plot.stop_iperf()

    def save_log(self):
        self.plot.save_log_now()

    def clear_counters(self):
        self.last_req = 0
        self.last_grant = 0
        self.req_label.config(text="Requests: 0")
        self.grant_label.config(text="Grants: 0")
        print("[Counters cleared]")

    def update_stats(self, req, grant):
        if req != self.last_req:
            self.req_label.config(text=f"Requests: {req}")
            self.last_req = req
        if grant != self.last_grant:
            self.grant_label.config(text=f"Grants: {grant}")
            self.last_grant = grant

# ====== Entry Point ======
if __name__ == "__main__":
    root = tk.Tk()
    app = ESP32IperfGUI(root)
    root.mainloop()
