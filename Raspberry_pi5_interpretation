import tkinter as tk
from tkinter import filedialog
import serial
import threading
import subprocess
import re
import csv
import pandas as pd
from datetime import datetime
from collections import deque
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.animation import FuncAnimation

# Data buffers
throughputs = deque(maxlen=200)
time_points = deque(maxlen=200)
time_counter = 0
lock = threading.Lock()

class SerialReader(threading.Thread):
    def __init__(self, port, baudrate, callback):
        super().__init__(daemon=True)
        self.callback = callback
        self.ser = serial.Serial(port, baudrate, timeout=1)

    def run(self):
        while True:
            try:
                line = self.ser.readline().decode(errors='ignore').strip()
                if line.startswith("STATS"):
                    parts = line.split(',')
                    if len(parts) == 3:
                        try:
                            _, req, grant = parts
                            self.callback(int(req.strip()), int(grant.strip()))
                        except:
                            pass
            except Exception as e:
                print(f"Serial error: {e}")

    def send_command(self, cmd: str):
        try:
            print(f"[UART SEND] {cmd}")
            self.ser.write((cmd + '\n').encode())
        except Exception as e:
            print(f"Write error: {e}")

class ThroughputPlot:
    def __init__(self, parent, config_getter):
        self.fig, self.ax = plt.subplots(figsize=(5, 3))
        self.canvas = FigureCanvasTkAgg(self.fig, master=parent)
        self.toolbar = NavigationToolbar2Tk(self.canvas, parent)
        self.toolbar.update()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        self.ani = FuncAnimation(self.fig, self.update_plot, interval=1000)
        self.iperf_process = None
        self.running = False
        self.full_log_file = None
        self.full_log_writer = None
        self.config_getter = config_getter
        self.ax.callbacks.connect('xlim_changed', self.on_xlim_change)
        self.showing_historical = False

    def update_plot(self, frame):
        if self.showing_historical:
            return
        with lock:
            if not time_points or not throughputs:
                return
            self.ax.clear()
            self.ax.plot(time_points, throughputs, label="Throughput (Mbit/s)")
            self.ax.set_title("iPerf3 Throughput (Live)")
            self.ax.set_xlabel("Time (s)")
            self.ax.set_ylabel("Mbit/s")
            self.ax.grid(True)
            self.ax.legend()

    def on_xlim_change(self, event_ax):
        xlim = event_ax.get_xlim()
        left, right = int(xlim[0]), int(xlim[1])
        if left < max(0, time_counter - 200):
            self.load_historical_data(left, right)
            self.showing_historical = True
        elif self.showing_historical and left >= max(0, time_counter - 200):
            self.showing_historical = False

    def load_historical_data(self, start_time, end_time):
        df = pd.read_csv(self.full_log_file.name)
        slice_df = df[(df["Time (s)"] >= start_time) & (df["Time (s)"] <= end_time)]
        self.ax.clear()
        self.ax.plot(slice_df["Time (s)"], slice_df["Throughput (Mbit/s)"])
        self.ax.set_title(f"Historical Throughput: {start_time}-{end_time}s")
        self.ax.set_xlabel("Time (s)")
        self.ax.set_ylabel("Mbit/s")
        self.ax.grid(True)
        self.canvas.draw()

    def start_iperf(self):
        global time_counter
        if self.running:
            return
        self.running = True

        ip, port, duration, interval, iperf_path, bitrate, parallel, window, dual = self.config_getter()
        full_log_name = f"iperf3_full_log_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv"
        self.full_log_file = open(full_log_name, 'w', newline='')
        self.full_log_writer = csv.writer(self.full_log_file)
        self.full_log_writer.writerow(["Time (s)", "Throughput (Mbit/s)"])

        def run():
            global time_counter
            cmd = [
                iperf_path, "-c", ip, "-p", port, "-t", duration,
                "-b", bitrate, "-i", interval, "-P", parallel, "-w", window
            ]
            if dual:
                cmd.append("-d")
            cmd.append("--forceflush")
            print(f"[iperf3 command] {' '.join(cmd)}")

            try:
                self.iperf_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                for line in iter(self.iperf_process.stdout.readline, ''):
                    if not self.running:
                        break
                    line = line.strip()
                    match = re.search(r'\[\s*\d+\]\s+\d+\.\d+-\d+\.\d+\s+sec\s+\S+\s+\S+\s+(\d+\.\d+)\s+Mbits/sec', line)
                    if match:
                        throughput = float(match.group(1))
                        with lock:
                            throughputs.append(throughput)
                            time_points.append(time_counter)
                            time_counter += 1
                        self.full_log_writer.writerow([time_counter, throughput])
            except Exception as e:
                print(f"[iperf3 error] {e}")
            finally:
                self.running = False
                if self.full_log_file:
                    self.full_log_file.close()

        threading.Thread(target=run, daemon=True).start()

class ESP32IperfGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ESP32 + iPerf3 Monitor")
        self.reader = None
        self.last_req = -1
        self.last_grant = -1
        self.build_gui()

    def build_gui(self):
        left = tk.Frame(self.root)
        left.pack(side=tk.LEFT, padx=10, pady=10)

        tk.Label(left, text="Serial Port:").pack()
        self.serial_port_entry = tk.Entry(left)
        self.serial_port_entry.insert(0, "COM9")
        self.serial_port_entry.pack()

        tk.Label(left, text="Baud Rate:").pack()
        self.baudrate_entry = tk.Entry(left)
        self.baudrate_entry.insert(0, "115200")
        self.baudrate_entry.pack()

        tk.Label(left, text="iPerf3 Path:").pack()
        self.iperf_path_entry = tk.Entry(left)
        self.iperf_path_entry.insert(0, "C:/path/to/iperf3.exe")
        self.iperf_path_entry.pack()

        tk.Label(left, text="Server IP:").pack()
        self.ip_entry = tk.Entry(left)
        self.ip_entry.insert(0, "192.168.1.4")
        self.ip_entry.pack()

        tk.Label(left, text="Port:").pack()
        self.port_entry = tk.Entry(left)
        self.port_entry.insert(0, "5202")
        self.port_entry.pack()

        tk.Label(left, text="Duration (s):").pack()
        self.duration_entry = tk.Entry(left)
        self.duration_entry.insert(0, "150")
        self.duration_entry.pack()

        tk.Label(left, text="Interval (s):").pack()
        self.interval_entry = tk.Entry(left)
        self.interval_entry.insert(0, "1")
        self.interval_entry.pack()

        tk.Label(left, text="Target Throughput (e.g. 220m/5):").pack()
        self.throughput_entry = tk.Entry(left)
        self.throughput_entry.insert(0, "220m/5")
        self.throughput_entry.pack()

        tk.Label(left, text="Parallel Streams:").pack()
        self.parallel_entry = tk.Entry(left)
        self.parallel_entry.insert(0, "4")
        self.parallel_entry.pack()

        tk.Label(left, text="Window Size (e.g. 250M):").pack()
        self.window_entry = tk.Entry(left)
        self.window_entry.insert(0, "250M")
        self.window_entry.pack()

        self.dual_mode = tk.BooleanVar()
        tk.Checkbutton(left, text="Dual Mode (-d)", variable=self.dual_mode).pack()

        right = tk.Frame(self.root)
        right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.plot = ThroughputPlot(right, self.get_config)

    def get_config(self):
        return (
            self.ip_entry.get().strip(),
            self.port_entry.get().strip(),
            self.duration_entry.get().strip(),
            self.interval_entry.get().strip(),
            self.iperf_path_entry.get().strip(),
            self.throughput_entry.get().strip(),
            self.parallel_entry.get().strip(),
            self.window_entry.get().strip(),
            self.dual_mode.get()
        )

if __name__ == "__main__":
    root = tk.Tk()
    app = ESP32IperfGUI(root)
    root.mainloop()
